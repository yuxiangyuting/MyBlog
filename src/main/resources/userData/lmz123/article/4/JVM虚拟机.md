## 1、什么是JVM？

JVM是Java virtual  Machine的缩写，即java虚拟机的意思。

**JVM分两种：**

​		1、java Hotspot client VM

​		2、java  Hotspot server VM

我们常用的是第二种

## 2、JDK与JRE的区别？

JRE是Java Runtime Environmental即 运行时环境的缩写，包含了像lang和util、Collection等等jar包，要把一个程序运行起来则必须靠jre。

JDK与JDK唯一的区别就是JDK自带一个tools&tools API，一些命令，列如java、javac、javadoc，Jconsole、javapj、jar、java VirtualVM等等，这些可以用来诊断java生产环境出现问题或者javadoc出现问题时候进行排查。

## 3、程序的跨平台

java：

​		编写完java源代码（源文件）后，java命令将其编译.class（字节码）文件，这个字节码文件即能在windows也能在Linux平台上运行。那么这是如何实现的呢，大家都知道，最终操作系统识别的都是机器码，只有0和1两个数字组成，所以这时候就到了展现JVM的作用的时候了，JVM虚拟机会在软件层面去屏蔽各个操作系统底层硬件指令层面的细节差异，从而达到编译一份class文件就能在多个平台上运行的目的。

​		在jdk环境下载的时候，需要选择操作系统版本，因为本身操作系统的环境就不一样，从class文件到操作系统底层其实是jre进行跨平台的，所以这是一个运行时跨平台。

![](I:\作业\JVM\QQ截图20200413192751.png)

> **接下来我们来看看JVM底层的一个构成**

JVM的主干部分：

1. 类加载子系统

2. JVM运行时数据区

3. 执行引擎

   ![](I:\作业\JVM\QQ截图20200413192855.png)

​    .class文件通过类加载子系统加载到内存中，即运行时数据区，最后执行引擎是怎么执行加载到运行时数据区的这份代码呢，其实首先都知道，main方法程序入口，本身就是一个线程，叫主线程，也是主线程开始去执行这份代码。

首先运行时数据区化分为两个维度：线程共享区域和线程私有区域,

​			线程共享区域又划分为：堆和方法区（元空间）

​			线程私有区域又划分为：栈、本地方法栈、程序计数器三块区域

**线程私有区域**

​		在执行代码的时候，这个线程会在线程私有区域的栈和本地方法栈和程序计数器各分配一块空间，而这三块空间都是各自私有的。

​		每一个方法都是以栈帧的形式存储在栈里面，栈是属于数据结构的内容，一想到栈就会想到first in last out，即先进后出。每个方法的变量的作用域在本方法内，方法执行完或者出栈作用域就失效了。如果类里面有个main方法和一个自己定义的方法，那么在运行时，main会在自定义的方法下面，此时这个自定义的方法在栈中就称为栈顶，在出栈的时候，这个自定义的方法会先出栈，然后才是main方法，遵循先进后出原则，在每个栈帧里面都有自己的数据结构,例如局部变量，操作数栈和方法出口。

​		那么JVM是如何在字节码文件和操作系统之间建立桥梁的呢？机器码也就是汇编语言，都是一些汇编的指令，

那么在JDK里面，就有那么一种叫javap的指令，它可以对字节码文件代码进行一个反汇编，生成jvm指令，如下图

![](I:\作业\JVM\QQ截图20200413202706.png)

```
leconst_null 	将null对象引用压不栈
iconst_m1 		将int类型常量-1压入栈
iconst_0 		将int类型常量0压入栈
istore_0		将int类型常量出栈赋值给对应的变量

iconst_1 		将int类型常量1压入栈
istore_1		将int类型常量出栈赋值给对应的变量

iconst_2 		将int类型常量2压入栈
istore_2		将int类型常量出栈赋值给对应的变量

iconst_3 		将int类型常量3压入栈
istore_3		将int类型常量出栈赋值给对应的变量

iconst_4 		将int类型常量4压入栈
istore_4		将int类型常量出栈赋值给对应的变量

iconst_5 		将int类型常量5压入栈
istore_5		将int类型常量出栈赋值给对应的变量

lconst_0 		将long类型常量0压入栈
lconst_1 		将long类型常量1压入栈
fconst_0 		将float类型常量0压入栈
fconst_1 		将float类型常量1压入栈
dconst_0 		将double类型常量0压入栈

lsub			执行long类型的减法
imul			执行int类型的乘法
lmul			执行long类型的乘法
idiv			执行int类型的除法
ldiv			执行long类型的除法
irem			计算int类型除法的余数
lrem			计算long类型除法的余数


dconst_1		将double类型常量1压入栈
bipush			将一个8位带符号整数压入栈

sipush			将16位带符号整数压入栈
ldc				把常量池中的项压入栈
ldc_w			把常量池中的项压入栈(使用宽索引)
ldc2_w			把常量池中long类型或者double类型的项压入栈(使用宽从栈中的局部变量中装载值的指令

```

![](I:\作业\JVM\QQ截图20200413205629.png)

![](I:\作业\JVM\QQ截图20200413205457.png)

![](I:\作业\JVM\QQ截图20200413211630.png)

![](I:\作业\JVM\QQ截图20200413211857.png)

![](I:\作业\JVM\QQ截图20200413212326.png)

![](I:\作业\JVM\QQ截图20200413212842.png)







**线程共享区域**

​		





